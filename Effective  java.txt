1.如果一个栈先是增长，然后再收缩（再增长可能就不会），从栈中弹出的对象不会被当做垃圾回收，即使使用栈的程序不再引用这些对象，它们也不会回收。
这是因为，栈内部维护着对这些对象的过期引用。所谓过期引用，是指永远也不会再被解除的引用。栈中数组，没存储元素的部分的引用都是过期引用。
如果一个对象的引用被保留起来，那么垃圾回收不仅不会处理这个对象，而且也不会处理被这个对象所引用的所有其他对象，从而对性能造成潜在的重大影响。

2.由于泛型信息在运行时被擦除，因此在参数化类型而非无限制通配符类型上使用instanceof操作符是非法的。用无限制通配符类型代替原生态类型，对instanceof操作符的行为不会产生任何影响。

3.Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合；Set<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合；Set则是个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。

4.限定通配符E与无限制通配符？的区别
限定通配符在类初始化的时候需要指定。如：
class Person<E>{
public void show(Person<E> person);
}

Person<Good> person = new Person<Good>();

5.数组与泛型
数组是协变的。如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类。相反，泛型则是不可变的，对于任意两个不同的类型Type1和Type2，List<Type>既不是List<Type2>的子类型，也不是List<Type2>的超类型。

6.枚举天生就是不可变的，因此所有的域都应为final的

7.缩短过长的参数列表
1）把方法分解成多个方法，每个方法只需要这些参数的一个子集。如果不小心，这样做会导致方法过多。
2）创建辅助类，用来保存参数的分组。这些辅助类一般为静态成员类。
3）从对象构建到方法调用都采用Builder模式。如果方法带有多个参数，尤其是当他们中有些可选的时候，最好定义一个对象来表示所有参数，并允许客户端在这个对象上进行多次setter调用，每次调用都设置一个参数，或者设置一个较小的相关的集合。
对于参数类型，要优先使用接口而不是类
对于boolean参数，要优先使用两个元素的枚举类型

8.返回零长度的数据或集合，而不是null
1)不用考虑分配数组所需要的开销会影响性能问题，因为在这个级别上担心性能问题是不明智的，除非分析标明这个方法正式造成性能问题的真正源头。
2）对于不返回任何元素的调用，每次都返回同一个零长度数组是可能的，因为零长度数据是不可变的，而不可变对象有可能被自由地共享。

9.当多个现成共享可变数据的时候，每个读或者写数据的线程都必须执行同步。如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知。



























